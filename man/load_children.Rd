% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_children.R
\name{load_children}
\alias{load_children}
\alias{read_children}
\alias{add_parent}
\title{Recursively Load Child Documents}
\usage{
load_children(all_parents)

read_children(parent, all_children = list(), ...)

add_parent(child, parent)
}
\arguments{
\item{all_parents}{a list of \link{Episode} objects}

\item{parent}{an \link{Episode} object}

\item{all_children}{a list of \link{Episode} objects}

\item{child}{an \link{Episode} object}
}
\value{
a list of \link{Episode} objects from the children. If no children exist,
then this is \code{NULL}. In the case of \code{add_parent()}, this is called for its
side-effect to update the child object and it always returns \code{NULL}.
}
\description{
Process a list of \link{Episode} objects to do two things:
\enumerate{
\item recursively read in the child documents declared in the parent
documents
\item for each child, update the \verb{$parent} and \verb{$build_parent} elements
}
}
\details{
When we want to build lessons, it's important to be able to find all of the
files that are necessary to build a particular file. If there is a modification in a child file, \pkg{sandpaper} needs to know that it should flag the parent
for rebuilding. To do this, we need two pieces of information:
\enumerate{
\item The earliest ancestors of a given child file
\item The full list of descendants of a given parent file
}

Each Episode object only knows about itself, so it can only report its
immediate children, but not the children of children, or even its parent
(unless we explicitly tell it what its parent is). The \link{Lesson} object
contains the context of all of the Episodes and can provide this information.

During Lesson object initialisation, the \code{load_children()} function is
called to process all source files for their children. This creates an
empty list of children that is continuously appended to during the function
call. It then calls \code{read_children()} on each parent file, which will append
itself as a parent to any existing children in the \code{all_children} list,
intitialize new \link{Episode} objects from the unread child files, and then
search those for children until there are no children left to read.
}
\examples{
ex <- lesson_fragment("sandpaper-fragment-with-child")
lsn <- Lesson$new(ex, jekyll = FALSE)
children <- load_children(lsn$episodes)

# load_children will start from scratch, so it will produce new Episode files
identical(names(children), names(lsn$children))
purrr::map2(children, lsn$children, identical)

# read children takes in a list of children episodes and appends that list
# with the descendants

# given a full list of children, it will return the same list
these_children <- read_children(lsn$episodes[[1]], children)
purrr::map2(these_children, children, identical)

# given a partial list, it will append to it
new_children <- read_children(lsn$episodes[[1]], children[1])
purrr::map2(new_children, children, identical)
}
\seealso{
\code{\link[=find_children]{find_children()}} for details on how child documents are discovered
}
\keyword{internal}
