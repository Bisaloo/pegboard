% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_children.R
\name{find_children}
\alias{find_children}
\alias{trace_children}
\title{Detect the child files of an Episode object}
\usage{
find_children(parent)

trace_children(parent, lsn)
}
\arguments{
\item{parent}{an \link{Episode} or \link[tinkr:yarn]{tinkr::yarn} object (\code{trace_children()}
requires an \code{Episode} object).}

\item{lsn}{a \link{Lesson} object that contains the \code{parent} and all its children.}
}
\value{
a character vector of the absolute paths to child files.
}
\description{
\itemize{
\item \code{find_children()} returns the \emph{immediate} children for any given Episode
object.
\item \code{trace_children()} is used \emph{after processing} in the context of a Lesson
to trace the entire lineage from a source parent episode.
}
}
\details{
It is possible to define \href{https://bookdown.org/yihui/rmarkdown-cookbook/child-document.html}{child documents}
in \pkg{knitr} documents by using the \code{child} attribute in code chunks. For
example, let's say we have a file called \code{episodes/parent.Rmd}:

\if{html}{\out{<div class="sourceCode markdown">}}\preformatted{This content is from _a child document_:

```\{r child = "files/the-child.Rmd"\}
```
}\if{html}{\out{</div>}}

where \code{files/the-child.Rmd} is relative to \code{episodes/parent.Rmd}

The \code{find_children()} function will extract the immediate children from
a single \link{Episode} object (in this case, it will return
\verb{/path/to/episodes/files/the-child.Rmd}), but it will not detect any further
descendants. To detect the entire lineage, the Episode must be read in the
context of a Lesson (or processed with \code{\link[=load_children]{load_children()}}).

This function is used during Episode initialisation to populate the
\verb{$children} element of the \code{Episode} object, which lists paths to the
known children for further processing.
\subsection{Tracing full lineages}{

It is possible for a child document to have further children defined:

\if{html}{\out{<div class="sourceCode markdown">}}\preformatted{This is the first child. The following content is from the grandchild:

```\{r child = "the-grandchild.md"\}
```
}\if{html}{\out{</div>}}

When an Episode is read \emph{in the context of a Lesson}, the children are
processed with \code{\link[=load_children]{load_children()}} so that each file with children will have a
non-zero value of the \verb{$children} element. We recurse through the \verb{$children}
element in the \link{Lesson} object to exhaust the search for the children files.

The \code{trace_children()} will return the entire lineage for a given \emph{parent}
file. Which, in the case of the examples defined above would be:
\verb{/path/to/episodes/parent.Rmd}, \verb{/path/to/episodes/files/the-child.Rmd},
and \verb{/path/to/episodes/the-grandchild.md}.
}

\subsection{NOTE}{

For standard lessons, child files are written relative to the parent file.
Usually, these child files will be in the \code{files} folder under their parent
folder. Overview lessons are a little different. For overview lessons (in
The Workbench, these are lessons which contain \code{overview: true} in
config.yaml), the child files may point to \code{files/child.md}, but in reality,
the child file is at the root of the lesson \code{../files/child.md}. We correct
for this by first checking that the child files exist and if they don't
defaulting to the top of the lesson.
}
}
\examples{
# needed for using internal functions: loading the namespace
pb <- asNamespace("pegboard")
# This example demonstrates a child document with another child document
# nested inside. First, we demonstrate how `find_children()` only returns
# the immediate children and then we demonstrate how the full lineage is
# extracted in the Lesson object.
#
# `find_children()` --------------------------------------------------------
ex <- lesson_fragment("sandpaper-fragment-with-child")

# The introduction has a single child file
intro <- tinkr::yarn$new(fs::path(ex, "episodes", "intro.Rmd"))
intro$head(21) # show the child file
pb$find_children(intro)
# this is identical to the `$children` element of an Episode object
ep <- Episode$new(fs::path(ex, "episodes", "intro.Rmd"))
ep$children

# Loading the child file reveals another child
child <- Episode$new(ep$children[[1]])
child$children
child$show()

# `trace_children()` -------------------------------------------------------
# In the context of the lesson, we can find all the descendants
lsn <- Lesson$new(ex, jekyll = FALSE)
pb$trace_children(ep, lsn)
# This is the same as using the method of the same name in the Lesson object
# using the path to the episode
lsn$trace_lineage(ep$path)
# show the children
purrr::walk(lsn$children, function(ep) {
    message("----", ep$path, "----")
    ep$show()
  }
)
}
\keyword{internal}
