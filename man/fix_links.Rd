% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fix_links.R
\docType{data}
\name{fix_links}
\alias{fix_links}
\alias{LINKS}
\alias{fix_link_type}
\alias{find_lesson_links}
\alias{resolve_links}
\alias{links_within_text_regex}
\alias{text_to_links}
\alias{make_link}
\title{Finds and fixes unresolved links within an Episode}
\format{
An object of class \code{list} of length 4.
}
\usage{
fix_links(body)

LINKS

fix_link_type(type, body)

find_lesson_links(body, type = "rel_link")

resolve_links(txt, type)

links_within_text_regex()

text_to_links(txt, ns = NULL, type, sourcepos = NULL)

make_link(txt, pattern, type = "rel_link")
}
\arguments{
\item{body}{an XML document.}

\item{type}{the type of link as defined in \link{LINKS}.}

\item{txt}{text derived from \code{xml2::xml_text()}}

\item{ns}{a namespace object}

\item{sourcepos}{defaults to NULL. If this is not NULL, it's the sourcepos
attribute of the text node(s) and will be applied to the new nodes.}

\item{pattern}{a regular expression that is used for splitting the link
from the surrounding text.}
}
\value{
\code{fix_links()}: the modified body

\code{fix_link_type()}: the xml document with new nodes added

\code{find_lesson_links()}: an xml nodeset of text nodes containing the
links that match the link type

\code{resolve_links()}: modified text nodes

\code{text_to_links()}: if ns is NULL: a character vector of XML text
nodes, otherwise, new XML text nodes.
}
\description{
\code{LINKS}: A list of XPath predicates

There are two reasons why commonmark would not recognise a link:
\enumerate{
\item The link is a relative link and the anchor is in another ~~castle~~ file.
\item The link source uses a liquid variable that contains spaces.
}

Because of this, we need to find these unparsed links in the document and
re-parse them as valid links.

\code{fix_link_type()}: Fixes all links in the document based on the type of link

\code{find_lesson_link()}: Finds all text nodes that contain the link type

\code{resolve_links()}: Operates on an individual text node within a paragraph.
\enumerate{
\item modify underlying text to new nodes, splitting off links
\item inserts all the modified nodes before the text node
\item remove the old text node
}

\code{links_within_text_regex()}: finding different types of links within markdown
text can be challenging because it involves characters used in regex for
grouping and character classes. In general, I want to do two things with text
that I get back from a document:
\enumerate{
\item split the links out from the text
\item identify which parts of the resulting vector are links.
}

This way, I can convert the links to links and the text to text.

\code{text_to_links()}: Splits links away from text and returns a nodeset to insert

\code{make_link()}: makes a link depending on the link type
}
\examples{
helpers <- pegboard:::links_within_text_regex()
helpers
txt <- "text ![image text](a.png) with [a link](b.org) and text"
res <- strsplit(txt, helpers["to_split"], perl = TRUE)[[1]]
data.frame(res)
grepl(helpers["find_links"], res, perl = TRUE)
txt <- "Some text [and a link]({{ page.root }}/link.to#thing), 
some other text [and another link][link-to-thing]."
pegboard:::text_to_links(txt, type = "rel_link")
md <- c(md = "http://commonmark.org/xml/1.0")
class(md) <- "xml_namespace"
pegboard:::text_to_links(txt, md, "rel_link")
}
\keyword{datasets}
