% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fix_links.R, R/utils.R
\name{fix_links}
\alias{fix_links}
\alias{find_broken_links}
\alias{fix_broken_links}
\alias{make_link_patterns}
\alias{get_link_fragment_nodes}
\alias{fix_broken_link}
\alias{links_within_text_regex}
\alias{text_to_links}
\alias{make_link}
\alias{find_between_nodes}
\title{Find and fix unresolved template links within an Episode XML body}
\usage{
fix_links(body)

find_broken_links(body)

fix_broken_links(fragments)

make_link_patterns(ns = "md:")

get_link_fragment_nodes(node)

fix_broken_link(nodes)

links_within_text_regex()

text_to_links(txt, ns = NULL, type, sourcepos = NULL)

make_link(txt, pattern, type = "rel_link")

find_between_nodes(a, b, include = TRUE)
}
\arguments{
\item{body}{an XML document.}

\item{ns}{a namespace object}

\item{node}{a node determined to be a text representation of a link
destination}

\item{txt}{text derived from \code{xml2::xml_text()}}

\item{type}{either "image" or "link".}

\item{sourcepos}{defaults to NULL. If this is not NULL, it's the sourcepos
attribute of the text node(s) and will be applied to the new nodes.}

\item{pattern}{a regular expression that is used for splitting the link
from the surrounding text.}
}
\value{
\code{fix_links()}: the modified body

\itemize{
\item \code{find_broken_link()}: a list where each element represents a fragmented
link. Inside each element are two elements:
\item parent: the parent paragraph node for the link
\item nodes: the series of four or five nodes that make up the link text
}

\itemize{
\item \code{get_link_fragments()}: the preceding three or four nodes, which will be
the text of the link or the alt text of the image.
}

\code{text_to_links()}: if ns is NULL: a character vector of XML text
nodes, otherwise, new XML text nodes.

\itemize{
\item \code{get_link_fragments()}: the preceding three or four nodes, which will be
the text of the link or the alt text of the image.
}
}
\description{
Links like \verb{[link text](\{\{ page.root \}\}/destination.html)} are not parsed
correctly by our commonmark parser and are output as text. Use this to find
these missing links and transform them into link or image elements.
}
\details{
\subsection{Motivation}{

Jekyll implements \href{https://shopify.github.io/liquid/}{the liquid template language}, which can break some syntax
expected by commonmark. If this syntax appears in a link context, that link
is rendred as text. Carpentries Lessons created before 2023 use Jekyll
and have this templating embedded for many links.

In order to convert a pre-workbench lesson to use The Workbench, we need to
make sure all the links are accurately represented to avoid invalid syntax
and broken links from sneaking into the lesson.
}

\subsection{Implementation Details}{

For example, a valid line with a link that looks
like \verb{[Home](index.html) and other text} will appear in XML as:

\if{html}{\out{<div class="sourceCode xml">}}\preformatted{...
<link destination="index.html">Home</link>
<text> and other text</text>
...
}\if{html}{\out{</div>}}

However, if a link uses liquid templating for a variable such as:
\verb{[Home](\{\{ page.root \}\}/index.html) and other text}, it will appear in XML as

\if{html}{\out{<div class="sourceCode xml">}}\preformatted{...
<text asis="true">[</text>
<text>Home</text>
<text asis="true">]</text>
<text>(\{\{ page.root \}\}/index.html) and other text</text>
...
}\if{html}{\out{</div>}}

Note: the nodes with \code{asis} elements are from \pkg{tinkr} protecting square
brackets. When we run \code{fix_links()}, these nodes are collapsed into a link:

\if{html}{\out{<div class="sourceCode xml">}}\preformatted{...
<link destination="\{\{ page.root \}\}/index.html">Home</link>
<text> and other text</text>
...
}\if{html}{\out{</div>}}

And with that we can further transform the link to replace the liquid
templating with something that makes sense in \pkg{sandpaper}.
}

\code{find_broken_links()} uses the pattern generated by \code{make_link_patterns()}
to search for potential links.

\code{fix_broken_links()} uses the output of \code{find_broken_links()} to replace the
node fragments with links.

\code{make_link_patterns()} a generator to create an XPath query that will search
for liquid markup following a closing bracket.

\code{get_link_fragment_nodes()}: Get the source for the link node fragments

\code{fix_broken_link()} takes a set of nodes that comprises a single link and
recomposes them into a link or image node.

\code{links_within_text_regex()}: finding different types of links within markdown
text can be challenging because it involves characters used in regex for
grouping and character classes. In general, I want to do two things with text
that I get back from a document:
\enumerate{
\item split the links out from the text
\item identify which parts of the resulting vector are links.
}

This way, I can convert the links to links and the text to text.

\code{text_to_links()}: Splits links away from text and returns a nodeset to insert

\code{make_link()}: makes a link depending on the link type
}
\examples{
loop <- fs::path(lesson_fragment(), "_episodes", "14-looping-data-sets.md")
e <- Episode$new(loop, fix_links = FALSE)
e$links  # five links
e$images # four images

# fix_links() ---------------------------------------------------------------
asNamespace("pegboard")$fix_links(e$body)
e$links  # eight links
e$images # five images

asNamespace("pegboard")$make_link_patterns()

# links_within_text_regex() -------------------------------------------------
helpers <- pegboard:::links_within_text_regex()
helpers
txt <- "text ![image text](a.png) with [a link](b.org) and text"
res <- strsplit(txt, helpers["to_split"], perl = TRUE)[[1]]
data.frame(res)
grepl(helpers["find_links"], res, perl = TRUE)

# text_to_links() -----------------------------------------------------------
txt <- "Some text [and a link]({{ page.root }}/link.to#thing), 
some other text."
pegboard:::text_to_links(txt, type = "link")
md <- c(md = "http://commonmark.org/xml/1.0")
class(md) <- "xml_namespace"
pegboard:::text_to_links(txt, md, "link")
}
\keyword{internal}
