---
title: "Working with XML data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with XML data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

You will want to read this vignette if you are interested in contributing to
{pegboard}, or if you would like to understand how to fine-tune the transition of
a lesson from the styles infrastructure to The Workbench (see 
<https://github.com/carpentries/lesson-transition#readme>), or if you want to
know how to better inspect the output of some of {pegboard}'s accessors. In
this vignette, I assume that you are familiar with writing R functions and that
R will default to passing an object's _value_ to a function and not a
_reference_ (though if you do not understand that last part, do not worry, I
will try to dispell this). 

The {pegboard} package is an enhancement of the {tinkr} package, which
transforms Markdown to XML and back again. This transformation is facilitated
by the [{commonmark}] for transforming Markdown to XML and [{xslt}] for
transforming XML to Markdown. The reason why we want to transform markdown to
XML is because this allows us to concisely extract and manipulate markdown
elements in a way that would not be possible with simple regular expressions.

[{commonmark}]: https://docs.ropensci.org/commonmark/
[{xslt}]: https://docs.ropensci.org/xslt/
[{xml2}]: https://xml2.r-lib.org/

## Working with XML data

Each `Episode` object contains a field (you can think of each field as a list 
element) called `$body`, which contains an {xml2} document. This is the core of
the `Episode` object and every function works in some way with this field. For
the casual R user (and even for the more experienced), the way you use this
package may seem a little strange. This is because in R, functions will not
have side effects, but the vast majority of methods in the `Episode` object will
modify the object itself and this all has to do with the way XML data is handled
in R by the {xml2} package. 

Normally in R, when you pass data to a function, it will make a copy of the
data and then apply the function to the copy of the data:

```{r}
x <- 1:10
f <- function(x) {
  # insert 99 after the fourth position in a vector
  return(append(x, 99, after = 4))
}
print(f(x))
# note that x is not modified
print(x)
```

When working with XML in R, the {xml2} package is unparalleled, but it leads to
surprising outcomes because when you modify content within an XML object, you
are modifying the object in place:

```{r xml-example}
x <- xml2::read_xml("<a><b></b></a>")
print(x)
f <- function(x, new = "c") {
  xml2::xml_add_child(x, new, .where = xml2::xml_length(x))
  return(x)
}
y <- f(x)
# note that x and y are identical
print(x)
print(y)
```

It gets a bit stranger when you consider that in the above code, `y` and `x` are
_exactly the same object_ as shown with the fact that if I manipulate `y`, then 
`x` will also be modified:

```{r xml-example-dup}
f(y, "d")
print(y)
print(x)
```

I can even extract child elements from the XML document and manipulate _those_
and have them be reflected in the parent. For example, if I extract the second
child of the document, and then apply the `cool="verified"` attribute to the 
child, it will be reflected in the parent document. 

```{r xml-example-child}
child <- xml2::xml_child(x, 2)
xml2::xml_set_attr(child, "cool", "verified")
print(child)
print(x)
print(y)
```

This persistance lends itself very well to using the {R6} package for creating
objects that work in a more object-oriented way (where methods belong to classes
instead of the other way around). If you are familiar with how Python methods
work, then you will be mostly familiar with how the {R6} objects behave. It is 
worthwhile to read the [{R6} introduction
vignette](https://r6.r-lib.org/articles/Introduction.html) if you want to
understand how to program and modify this package. 

In the example above, you notice that I use `xml2::xml_child()` to extract child
nodes, but the real power of XML comes with searching for items using XPath
syntax for traversing the XML nodes where I would be able to do one of the
following to get the child called "c"

```{r xml-example-xpath}
xml2::xml_find_first(x, ".//c")
xml2::xml_find_first(x, "/a/c")
```

The next section will cover a bit of XPath and provide some resources on how to
practice and learn because this comes in very handy to quickly traverse the XML
nodes without relying on loops.

## XPath

In the section, we will talk about XPath syntax. 

BLAH BLAH BLAH STUFF FOR NERDS

In the next section, I will discuss how to extract and manipulate XML that comes
from Markdown with namespaces.

## XML data from Markdown using namespaces

The XML from markdown transformation is fully handled by the {commonmark}
package, which has the convenient `commonmark::markdown_xml()` function. For
example, this is how how the following markdown is processed:

```markdown
This is a bunch of [example markdown](https://example.com 'for example') text

- this
- is
- a **list**
```

> This is a bunch of [example markdown](https://example.com 'for example') text
> 
> - this
> - is
> - a **list**


```{r commonmark-ex}
md <- c("This is a bunch of [example markdown](https://example.com 'for example') text",
  "",
  "- this",
  "- is",
  "- a **list**"
)
xml_txt <- commonmark::markdown_xml(paste(md, collapse = "\n"))
class(xml_txt)
writeLines(xml_txt)
```

You can see that it has successfully parsed the markdown into a paragraph and
a list and then the various elements within. 


