---
title: "Working with XML data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with XML data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The {pegboard} package is an enhancement of the {tinkr} package, which
transforms Markdown to XML and back again. This transformation is facilitated
by the [{commonmark}] for transforming Markdown to XML and [{xslt}] for
transforming XML to Markdown. The reason why we want to transform markdown to
XML is because this allows us to concisely extract and manipulate markdown
elements in a way that would not be possible with simple regular expressions. 



[{commonmark}]: https://docs.ropensci.org/commonmark/
[{xslt}]: https://docs.ropensci.org/xslt/
[{xml2}]: https://xml2.r-lib.org/

## Working with XML data

Each `Episode` object contains a field (you can think of each field as a list 
element) called `$body`, which contains an {xml2} document. This is the core of
the `Episode` object and every function works in some way with this field. For
the casual R user (and even for the more experienced), the way you use this
package may seem a little strange. This is because in R, functions will not
have side effects, but the vast majority of methods in the `Episode` object will
modify the object itself and this all has to do with the way XML data is handled
in R by the {xml2} package. 

Normally in R, when you pass data to a function, it will make a copy of the
data and then apply the function to the copy of the data:

```{r}
x <- 1:10
f <- function(x) {
  # insert 99 after the fourth position in a vector
  return(append(x, 99, after = 4))
}
print(f(x))
# note that x is not modified
print(x)
```

When working with XML in R, the {xml2} package is unparalleled, but it leads to
surprising outcomes because when you modify content within an XML object, you
are modifying the object in place:

```{r xml-example}
x <- xml2::read_xml("<a><b></b></a>")
print(x)
f <- function(x, new = "c") {
  xml2::xml_add_child(x, new, .where = xml_length(x))
  return(x)
}
y <- f(x)
# note that x and y are identical
print(x)
print(y)
```

It gets a bit stranger when you consider that in the above code, `y` and `x` are
_exactly the same object_ as shown with the fact that if I manipulate `y`, then 
`x` will also be modified:

```{r xml-example-dup}
f(y, "d")
print(y)
print(x)
```

I can even extract child elements from the XML document and manipulate _those_
and have them be reflected in the parent. For example, if I extract the second
child of the document, and then apply the `cool="verified"` attribute to the 
child, it will be reflected in the parent document. 

```{r xml-example-child}
child <- xml2::xml_child(x, 2)
xml2::xml_set_attr(child, "cool", "verified")
print(child)
print(x)
print(y)
```

This persistance lends itself very well to using the {R6} package for creating
objects that work in a more object-oriented way (where methods belong to classes
instead of the other way around). If you are familiar with how Python methods
work, then you will be mostly familiar with how the {R6} objects behave. It is 
worthwhile to read the [{R6} introduction
vignette](https://r6.r-lib.org/articles/Introduction.html) if you want to
understand how to program and modify this package. 

