---
title: "Working with XML data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with XML data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

You will want to read this vignette if you are interested in contributing to
{pegboard}, or if you would like to understand how to fine-tune the transition of
a lesson from the styles infrastructure to The Workbench (see 
<https://github.com/carpentries/lesson-transition#readme>), or if you want to
know how to better inspect the output of some of {pegboard}'s accessors. In
this vignette, I assume that you are familiar with writing R functions and that
R will default to passing an object's _value_ to a function and not a
_reference_ (though if you do not understand that last part, do not worry, I
will try to dispell this). 

The {pegboard} package is an enhancement of the {tinkr} package, which
transforms Markdown to XML and back again. [XML is a markup language that
is derived from HTML](https://www.geeksforgeeks.org/html-vs-xml/) designed to 
handle structured data. A more modern format for storing and transporting data
on the web is JSON, but the advantage of using XML is that we are able to use the
[XPath] language to parse it (more on that later). Moreover, because XML has
the same structure as HTML, it can be parsed using the same tools, which is
advantageous for a suite of packages that transforms Markdown to HTML. This
transformation is facilitated by the [{commonmark}] for transforming Markdown
to XML and [{xslt}] for transforming XML to Markdown. 

[{commonmark}]: https://docs.ropensci.org/commonmark/
[{xslt}]: https://docs.ropensci.org/xslt/
[{xml2}]: https://xml2.r-lib.org/
[XPath]: https://en.wikipedia.org/wiki/XPath

## Working with XML data

Each `Episode` object contains a field (you can think of each field as a list 
element) called `$body`, which contains an {xml2} document. This is the core of
the `Episode` object and every function works in some way with this field. For
the casual R user (and even for the more experienced), the way you use this
package may seem a little strange. This is because in R, functions will not
have side effects, but the vast majority of methods in the `Episode` object will
modify the object itself and this all has to do with the way XML data is handled
in R by the {xml2} package. 

Normally in R, when you pass data to a function, it will make a copy of the
data and then apply the function to the copy of the data:

```{r}
x <- 1:10
f <- function(x) {
  # insert 99 after the fourth position in a vector
  return(append(x, 99, after = 4))
}
print(f(x))
# note that x is not modified
print(x)
```

When working with XML in R, the {xml2} package is unparalleled, but it leads to
surprising outcomes because when you modify content within an XML object, you
are modifying the object in place:

```{r xml-example}
x <- xml2::read_xml("<a><b></b></a>")
print(x)
f <- function(x, new = "c") {
  xml2::xml_add_child(x, new, .where = xml2::xml_length(x))
  return(x)
}
y <- f(x)
# note that x and y are identical
print(x)
print(y)
```

It gets a bit stranger when you consider that in the above code, `y` and `x` are
_exactly the same object_ as shown with the fact that if I manipulate `y`, then 
`x` will also be modified:

```{r xml-example-dup}
f(y, "d")
print(y)
print(x)
```

I can even extract child elements from the XML document and manipulate _those_
and have them be reflected in the parent. For example, if I extract the second
child of the document, and then apply the `cool="verified"` attribute to the 
child, it will be reflected in the parent document. 

```{r xml-example-child}
child <- xml2::xml_child(x, 2)
xml2::xml_set_attr(child, "cool", "verified")
print(child)
print(x)
print(y)
```

This persistance lends itself very well to using the {R6} package for creating
objects that work in a more object-oriented way (where methods belong to classes
instead of the other way around). If you are familiar with how Python methods
work, then you will be mostly familiar with how the {R6} objects behave. It is 
worthwhile to read the [{R6} introduction
vignette](https://r6.r-lib.org/articles/Introduction.html) if you want to
understand how to program and modify this package. 

In the example above, you notice that I use `xml2::xml_child()` to extract child
nodes, but the real power of XML comes with searching for items using XPath
syntax for traversing the XML nodes where I would be able to do one of the
following to get the child called "c"

```{r xml-example-xpath}
xml2::xml_find_first(x, ".//c")
xml2::xml_find_first(x, "/a/c")
```

The next section will cover a bit of XPath and provide some resources on how to
practice and learn because this comes in very handy to quickly traverse the XML
nodes without relying on loops.

## Using XPath to parse XML

### The structure of XPath

In the section, we will talk about [XPath syntax][XPath-1.0], but it will be 
non-exhaustive. Unfortunately, good tutorials on the web are few and far between,
but here are some that can help:

 - The [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/XPath)
   is _usually_ pretty good, but instead, it's better as a reference
   - [MDN XPath Axes](https://developer.mozilla.org/en-US/docs/Web/XPath/Axes)
     good for knowing how to navigate among nodes
   - [MDN XPath
     functions](https://developer.mozilla.org/en-US/docs/Web/XPath/Functions)
     good for knowing how to filter node matches
 - The [w3schools tutorial on
   XPath](https://www.w3schools.com/xml/xpath_intro.asp) is actually one of the
   best out there, but this is an excpetion to the rule. Other than this
   tutorial, I would not trust any content from w3schools (they are not aligned
   at all with the web consortium).
 - An [XPath tester](https://extendsclass.com/xpath-tester.html) like a regex
   tester to allow you to try out complex queries in a visual manner.

It's important to remember that an XML document is a tree-like structure that
is similar to directories or folders on your computer. For example, if you look
at the source directory structure of this package, you would see a folder
called `R/` and a nested folder called `tests/testhat/`. If you started from
the root directory of this package, you would list the R files in the `R/`
folder with `ls R/*.R` similarly, if you wanted to list the R files in the
`tests/testthat/` folder, you would us `ls tests/testthat/*.R`. In this
respect, XPath has a very similar syntax: to enter the next level of nesting,
you add a slash (`/`). For example, let's take a look a what the file structure
would look like in XML form:

```{r XML-files, echo = FALSE, results = "asis"}
x <- '<ROOT>
  <R>
    <file ext="R">one</file>
    <file ext="R">two</file>
  </R>
  <tests>
    <testthat>
      <data>
        <file ext="txt">test-data</file>
      </data>
      <file ext="R">test-one</file>
      <file ext="R">test-two</file>
    </testthat>
  </tests>
</ROOT>'
writeLines(c("```xml", x, "```"))
xml <- xml2::read_xml(gsub("\\n", "", x))
```

The XPath syntax to find all files in the the R and testthat folders would be
the same if you started from the root: `R/file` and 
`tests/testthat/file`

```{r}
xml2::xml_find_all(xml, "R/file")
xml2::xml_find_all(xml, "tests/testthat/file")
```

However, XPath has one advantage that normal command line syntax doesn't have:
you can short-cut paths, so if we wanted to find all files in any given folder,
you can use the double slash (`//`) to recursively search through nesting:

```{r}
xml2::xml_find_all(xml, "//file")
```

Of course, this method finds _all_ files, so if you wanted to filter them, you
can use the bracket notation to create filters for our selection:

```{r}
xml2::xml_find_all(xml, "//file[@ext='R']")
```

In this scheme, I've put the file names as the text of the nodes, so we can
use the bracket notation again with [XPath functions](https://developer.mozilla.org/en-US/docs/Web/XPath/Functions) to filter for only files that contain "one"

```{r}
xml2::xml_find_all(xml, "//file[@ext='R'][contains(text(), 'one')]")
```

If I only wanted to extract source files that contain "one", I could also use
the `parent::` [XPath axis](https://developer.mozilla.org/en-US/docs/Web/XPath/Axes):

```{r}
xml2::xml_find_all(xml, "//file[@ext='R'][contains(text(), 'one')][parent::R]")
```

Note that if I used a slash (`/`) instead of square brackets for the parent, I
would get the parent back:

```{r}
xml2::xml_find_all(xml, "//file[@ext='R'][contains(text(), 'one')]/parent::R")
```

[XPath-1.0]: https://en.wikipedia.org/wiki/XPath#Syntax_and_semantics_(XPath_1.0)

In the next section, I will discuss how to extract and manipulate XML that comes
from Markdown with namespaces.

## XML data from Markdown using namespaces

The XML from markdown transformation is fully handled by the {commonmark}
package, which has the convenient `commonmark::markdown_xml()` function. For
example, this is how how the following markdown is processed:

```markdown
This is a bunch of [example markdown](https://example.com 'for example') text

- this
- is
- a **list**
```

> This is a bunch of [example markdown](https://example.com 'for example') text
> 
> - this
> - is
> - a **list**


```{r commonmark-ex}
md <- c("This is a bunch of [example markdown](https://example.com 'for example') text",
  "",
  "- this",
  "- is",
  "- a **list**"
)
xml_txt <- commonmark::markdown_xml(paste(md, collapse = "\n"))
class(xml_txt)
writeLines(xml_txt)
```

You can see that it has successfully parsed the markdown into a paragraph and
a list and then the various elements within. 


