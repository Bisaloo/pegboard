---
title: "Introduction to the Lesson Object"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to the Lesson Object}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

```{r child="../man/rmd-fragments/intro-class.Rmd"}
```

If you have a list of `Episode` objects, you can achieve _most_ of what you can
with the lesson objects, because much of the `Lesson` object's function is to
provide a methods that map over all of the `Episode` object methods. The key
difference between `Lesson` objects and a list of `Episode` objects is that
the `Lesson` object will collapse summaries and to map relations between 
`Episodes` and their children or parent documents.

**Before you read this vignette, please read the vignette on the `Episode` object
(`vignette("intro-episode", package = "pegboard")`)** so that you can understand
the methods that come from the `Episode` objects. In this vignette, we will talk
about the structure of `Lesson` objects, how to use the basic methods of these
objects, inspecting summaries of source vs built episodes, and assessing the
lineage of episodes that have parents and/or children documents. But first,
because of a default parameter, I need to explain a little bit about Jekyll,
the former lesson infrastructure. 

### A Brief Word About History and Jekyll

Prior to The Workbench, we had the [styles
repository](https://github.com/carpentries/styles/), which was an all-in-one
toolbox that built websites with Jekyll. It was colloquially known as the 
"Lesson Template." It has two major differences to The Workbench: folder 
structure and syntax.

#### Folder Structure

The folder structure of lessons built with Jekyll was one where content and
tooling lived side-by-side. This folder structure looked something like this:


```{r, jekyll-folders, echo = FALSE, comment = "# "}
writeLines(".
├── Gemfile
├── Makefile
├── _config.yml
├── \033[01;34m_episodes/\033[0m
│   └── 01-intro.md
├── \033[01;34m_episodes_rmd/\033[0m
├── \033[01;34m_extras/\033[0m
│   ├── a.md
│   └── b.md
├── \033[01;34m_includes/\033[0m
├── \033[01;34m_layouts/\033[0m
├── aio.md
├── \033[01;34massets/\033[0m
├── \033[01;34mbin/\033[0m
├── \033[01;34mfig/\033[0m
├── index.md
├── reference.md
├── requirements.txt
└── setup.md
")
```

When {pegboard} was first written, we initially assumed this folder structure,
where R Markdown and regular Markdown episodes lived in different folders (and
more often than not, the outputs of the R Markdown files lived inside the 
`_episodes/` folder. The main method of organising episodes was by numbers
embedded in the name of the files.

As The Workbench developed, it was clear that this folder structure needed to
change, but we needed to keep compatibility with the old lessons because we
want to ensure that people can independently convert from the old style lessons
to the new style, thus we added the `jekyll` parameter to the `Lesson` object
initializer method, and set `jekyll = TRUE` as the default to keep backwards
compatibility.

#### Syntax

```{r child="../man/rmd-fragments/jekyll-syntax.Rmd"}
```

## Creating a New Lesson Object

The `Lesson` object is invoked with the `Lesson$new()`, method. Here, I will
demonstrate a Workbench lesson. This is the folder structure of the workbench
lesson:

```{r intro-read-noshow, echo = FALSE, comment = "# "}
withr::with_dir(pegboard::lesson_fragment("sandpaper-fragment"), {
  fs::dir_tree(regex = "site/[^R].*", invert = TRUE)
})
```

To read it in, because we have a Workbench lesson, we need to specify `jekyll =
FALSE` to register all the div tags and ensure that the lesson is being treated
like a Workbench lesson.

```{r setup}
library("pegboard")
library("glue")
library("fs")
wbfragment <- lesson_fragment("sandpaper-fragment")
print(wbfragment) # path to the lesson
wb_lesson <- Lesson$new(wbfragment, jekyll = FALSE)
print(wb_lesson)
```

The Lesson printing here shows that it has a subset of methods that are named
similarly to methods and active bindings from the Episode class. These are not
inherited, but rather they are implemented across all the Episode objects. The
Episode objects themselves are parsed into one of three elements: "episodes",
"children", and "extra" (NOTE: the "extra" slot may be superceded by elements 
that better match the folder structure of lessons).

```{r show-episodes}
lapply(wb_lesson$episodes, class)
lapply(wb_lesson$children, class)
lapply(wb_lesson$extra, class)
```

## File Information

The Lesson object contains information about the file information:

```{r show-files}
# what is the root path for the lesson?
wb_lesson$path
# what episode files exist?
wb_lesson$files
# do any of the files have children (Workbench lessons only)? 
wb_lesson$has_children
```

## Creating a New Lesson with Child Documents

The Lesson object is very useful with Lessons that contain child documents
(see the `pegboard::find_children()` documentation for details).
Take for example the same lesson, but `episodes/intro.Rmd` has the child
`episodes/files/cat.Rmd` which in turn has the child
`episodes/files/session.Rmd`:

```{r intro-read-noshow-children, echo = FALSE, comment = "# "}
withr::with_dir(lesson_fragment("sandpaper-fragment-with-child"), {
  fs::dir_tree(regex = "site/[^R].*", invert = TRUE)
})
```

In this case, the `Lesson` object will detect that at least one `Episode`
references a child document and reads them in:

```{r show-children-files}
wbchild <- lesson_fragment("sandpaper-fragment-with-child")
wb_lesson_child <- Lesson$new(wbchild, jekyll = FALSE)
wb_lesson_child$has_children
lapply(wb_lesson_child$children, class)
```

The reason it is useful is because if you have a child Episode object, you can
determine its parent and its final ancestor. Because these paths are absolute
paths, I am going to write a function that will use the {glue} package to print
it nicely for us: 

```{r show-parent}
show_child_parents <- function(child) {
  parents <- fs::path_rel(child$parents, start = child$lesson)
  build_parents <- fs::path_rel(child$build_parents, start = child$lesson)

  msg <- "Ancestors for {child$name} ---
  Parent(s):         {parents}
  Final ancestor(s): {build_parents}"
  glue::glue(msg)
}

# cat.Rmd's parent is intro.Rmd
show_child_parents(wb_lesson_child$children[[1]])

# session.Rmd's parent is cat.Rmd
show_child_parents(wb_lesson_child$children[[2]])
```

If you have the name of the final ancestor, then you can determine the full
lineage with the `$trace_lineage()` method, which is useful for determining if
a file should be rebuilt:

```{r show-lineage}
parent <- wb_lesson_child$children[[2]]$build_parents
print(parent)
lineage <- wb_lesson_child$trace_lineage(parent)

# printing the lineage in a presentable fashion:
rel <- wb_lesson_child$path
pretty_lineage <- path_rel(lineage, start = rel)
pretty_lineage <- glue_collapse(pretty_lineage, sep = ", ", last = ", and ")
glue("The lineage of {path_rel(parent, start = rel)} is:
  {pretty_lineage}")
```




