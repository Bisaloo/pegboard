---
title: "Introduction to the Episode Object"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to the Episode Object}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The {pegboard} package facilitates the analysis and manipulation of Markdown and
R Markdown files by translating them to XML and back again. This extends the
{tinkr} package by providing additional methods that are specific for 
Carpentries-style lessons. There are two `R6` classes defined in {pegboard}:

 - `Episode` objects that contain the XML data, YAML metadata and extra fields
   that define the child and parent files for a particular episode
 - `Lesson` objects that contain lists of `Episode` objects categorised as 
   "episodes", "extra", or "children"

This vignette will be discussing the structure of Episode objects, how to 
query the contents with the {xml2} package, and how to use the methods and 
active bindings to get information about, extract, and manipulate anything
inside of a Markdown or R Markdown document.

## Reading Markdown Content

Each `Episode` object starts from a Markdown file. In particular for {pegboard},
we assume that this Markdown file is written using
[Pandoc](https://pandoc.org/MANUAL.html) syntax (a superset of
[CommonMark](https://commonmark.org/)). It can be any markdown file, but for us
to explore what the `Episode` object has to offer us, let's take an example R
Markdown file that is present in a fragment of a Carpentries Workbench lesson
that we have in this package. We will be using the {xml2} package to explore
the object and the {fs} package to help with constructing file paths.

```{r setup}
library("pegboard")
library("xml2")
library("fs")
```

This is what our lesson fragment looks like. It is a fragment because it's main
purpose is to be used for examples and tests, but it contains the basic structure
of a lesson that we want. 

```{r intro-read-noshow, echo = FALSE}
dir_tree(lesson_fragment("sandpaper-fragment"), recurse = 1, regex = "site/[^R].*", invert = TRUE)
```

We can retrieve it with the `lesson_fragment()` function, which loads example
data from pegboard. Here we will take that lesson fragment and read in the first
episode with the initialization method, `Episode$new()`, followed by
`$confirm_sandpaper()`, a confirmation that the episode was created to work
with [{sandpaper}], the user interface and build engine of The Carpentries
Workbench (for information on non-workbench content, see the section on [Jekyll
Lesson Markdown Content](#jekyll-lesson-markdown-content)) and `$protect_math()`
which will prevent special characters in LaTeX math from being escaped.

[{sandpaper}]: https://carpentries.github.io/sandpaper/

```{r intro-read}
lsn <- lesson_fragment("sandpaper-fragment")
# Read in the intro.Rmd document as an `Episode` object
intro_path <- path(lsn, "episodes", "intro.Rmd")
intro <- Episode$new(intro_path)$confirm_sandpaper()$protect_math()
```

If we print out the Episode object, I'm going to get a long list of methods,
fields and active bindings (functions that act like fields) printed:

```{r intro-print}
intro
```

The actual XML content is in the `$body` field. This contains all the data from
the markdown document, but in XML form. 

```{r intro-body}
intro$body
```

If we want to see what the contents look like, you can use the `$show()`,
`$head()`, or `$tail()` methods (note: the `$show()` method will print out the
entire markdown document).

```{r intro-show}
intro$head(10)
intro$tail(10)
intro$show()
```

## Analysis

You can use {pegboard} to account for and manipulate elements within the
document via special active bindings and methods:

For information about the file and its relationship to other files, you can use
the following active bindings, which are useful when working with Episodes in a
lesson context.

```{r file-active-bindings}
intro$path
intro$name
intro$lesson
# NOTE: relationships to other episodes are automatically handled in the
#       Lesson context
intro$has_parents
intro$has_children
intro$children # separate documents processed as if they were part of this document
intro$parents  # the immediate documents that would require this document to build
intro$build_parents # the final documents that would require this document to build
```

It is possible to find markdown elements from XPath statments:

```{r xpath-active-bindings}
xml2::xml_find_all(intro$body, ".//md:link", ns = intro$ns)
xml2::xml_find_first(intro$body, ".//md:list[@type='ordered']", ns = intro$ns)
```

However, there are some useful elements that we want to know about, so I have
implemented them in active bindings and methods:


```{r active-bindings}
# headings where level 2 headings are equivalent to sections
intro$headings
# all callouts/fenced divs
intro$get_divs()
intro$challenges
intro$solutions
# questions, objectives, and keypoints are standard and return char vectors
intro$objectives 
intro$questions
intro$keypoints
# code blocks and output types
intro$code
intro$output
intro$warning
intro$error
# images and links
intro$images
intro$get_images() # parses images embedded in `<img>` tags
intro$links
```

Much of these are summarized in the `$summary()` method:

```{r summary}
intro$summary()
```

## Manipulation

Because everything centers around the `$body` element and is extracted with 
{xml2}, it's possible to manipulate the elements of the document. One thing that
is possible is that we can add new content to the document using the `$add_md()`
method, which will add a markdown element after any paragraph in the document.

For example, we can add information about pegboard with a new code block after 
the first heading:

````{r add-code-block}
intro$head(26) # first 26 lines
intro$body # first heading is item 11
cb <- c("You can clone the **{pegboard} package**:

```sh
git clone https://github.com/carpentries/pegboard.git
```
")
intro$add_md(cb, where = 11)
intro$head(26) # code block has been added
intro$code
````

You can also manipulate existing elements. For example, let's say we wanted to
make sure all R code chunks were named. We can do so by querying and
manipulating the code blocks:

```{r update-code-block}
code <- intro$code
code
# executable code chunks will have the "language" attribute
is_chunk <- xml2::xml_has_attr(code, "language")
chunks <- code[is_chunk]
chunk_names <- xml2::xml_attr(chunks, "name")
nonames <- chunk_names == ""
chunk_names[nonames] <- paste0("chunk-", seq(sum(nonames)))
xml2::xml_set_attr(chunks, "name", chunk_names)
code
```

We can see that the chunks now have names, but the proof is in the rendering:

```{r}
intro$show()
```



## Jekyll Lesson Markdown Content

This section describes the features that you would expect to find in a lesson
that was built with the former infrastructure,
<https://github.com/carpentries/styles>, which was built using the Jekyll
static site generator. These style lessons are no longer supported by The
Carpentries. {pegboard} does support these lessons so that they can be 
transitioned to use The Workbench syntax. 
